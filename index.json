[{"authors":null,"categories":null,"content":"I am currently a postdoctoral researcher at the IMDEA Software Institute, working on new solving techniques for Presburger arithmetic (under the supervision of Pierre Ganty and Alessio Mansutti).\nI am interested in theoretical computer science, with a special interest in the theory and applications of decision procedures for formal verification.\nI completed my PhD at LAAS-CNRS, where I worked on new methods for taking advantage of Petri net reductions with an SMT-based model checker.\nDownload my resumé.\n","date":1705276800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1705276800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"","publishdate":"0001-01-01T00:00:00Z","relpermalink":"","section":"authors","summary":"I am currently a postdoctoral researcher at the IMDEA Software Institute, working on new solving techniques for Presburger arithmetic (under the supervision of Pierre Ganty and Alessio Mansutti).\nI am interested in theoretical computer science, with a special interest in the theory and applications of decision procedures for formal verification.","tags":null,"title":"Nicolas Amat","type":"authors"},{"authors":["Nicolas Amat","Silvano Dal Zilio","Didier Le Botlan"],"categories":null,"content":"","date":1705276800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1705276800,"objectID":"fb85814c5a8293b9af9f19203dce6cd4","permalink":"https://nicolasAmat.github.io/publication/vmcai_2024/","publishdate":"2022-04-06T00:00:00Z","relpermalink":"/publication/vmcai_2024/","section":"publication","summary":"We propose a method for checking generalized reachability properties in Petri nets that takes advantage of structural reductions and that can be used, transparently, as a pre-processing step of existing model-checkers. Our approach is based on a new procedure that can project a property, about an initial Petri net, into an equivalent formula that only refers to the reduced version of this net. Our projection is defined as a variable elimination procedure for linear integer arithmetic tailored to the specific kind of constraints we handle. It has linear complexity, is guaranteed to return a sound property, and makes use of a simple condition to detect when the result is exact. Experimental results show that our approach works well in practice and that it can be useful even when there is only a limited amount of reductions.","tags":["Petri nets","Quantifier elimination","Reachability problems"],"title":"Project and Conquer: Fast Quantifier Elimination for Checking Petri Net Reachability","type":"publication"},{"authors":["Nicolas Amat"],"categories":null,"content":"","date":1701648000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1701648000,"objectID":"22c2f12530678a19bd062de285b871ff","permalink":"https://nicolasAmat.github.io/publication/amat_phd_thesis/","publishdate":"2020-06-01T00:00:00Z","relpermalink":"/publication/amat_phd_thesis/","section":"publication","summary":"We propose and study a method to accelerate the verification of reachability problems in Petri nets based on structural reductions. This approach, that we call polyhedral reduction, relies on a state space abstraction that combines structural reductions and linear arithmetic constraints on the marking of places.\n\nThe correctness of this method is based on a new notion of equivalence between nets. Combined with an SMT-based model checker, one can transform a reachability problem about some Petri net, into the verification of an equivalent reachability property on a reduced version of this net. We also propose an automated procedure to prove that such an abstraction is correct, exploiting a connection with a class of Petri nets with Presburger-definable reachability sets.\n\nIn addition, we present a data structure, called Token Flow Graph (TFG), that captures the particular structure of constraints stemming from structural reductions. We leverage TFGs to efficiently solve two problems. First, to eliminate quantifiers that appear during our transformation, in the updated formula to be checked on the reduced net. Second, to compute the concurrency relation of a net, that is all pairs of places that can be marked simultaneously in some reachable marking.\n\nWe apply our approach to several symbolic model checking procedures and introduce a new semi-decision procedure for checking reachability properties in Petri nets based on the Property Directed Reachability (PDR) method. A distinctive feature of this PDR method is its ability to generate verdict certificates that can be verified using an external SMT solver.\n\nOur approach and algorithms are implemented in four open-source tools: SMPT for checking reachability properties; Kong for accelerating the computation of concurrent places; Octant for eliminating quantifiers; and Reductron for automatically proving the correctness of polyhedral reductions. We give experimental results about their effectiveness, both for bounded and unbounded nets, using a large benchmark provided by the Model Checking Contest. We focus on the reproducibility of our results and provide an accompanying artifact that covers all our experiments.","tags":[],"title":"PhD Thesis: A polyhedral Framework for Reachability Problems in Petri Nets","type":"publication"},{"authors":null,"categories":null,"content":"About SMPT is a SMT-based model checker for Petri nets focused on reachability problems that takes advantage of net reductions (polyhedral reductions).\nInstallation Requirements Python \u0026gt;= 3.7 (Optional) mypy - static type checker (Optional) sphinx - Python documentation generator z3 - SMT solver Tina toolbox - Friend tools (Optional) ndrio - Petri net converter (.pnml to .net) (Optional) reduce - Petri net reducer struct 4ti2 or LattE integrale (Optional) walk - Random state space explorer (Optional) tina - State space generator (Optional) play - Stepper simulator (Optional) mcc - Petri net unfolder (Optional) Octant - Quantifier eliminator for polyhedral reductions (Optional) MiniZinc - Constraint programming solver Commands The tool can be installed using pip:\n$ python setup.py bdist_wheel $ python -m pip install --user dist/smpt-5.0-py3-none-any.whl Note that the wheel package is required, you can install it using:\n$ pip3 install --user wheel To automatically install dependencies (except Python packages and MiniZinc) you can run the dependencies/install.sh script.\nType checking The typing of the code can be checked using mypy by running:\n$ mypy smpt --no-strict-optional Documentation generation The html documentation can be generated using the sphinx generator by running:\n$ cd docs $ make html Running the model checker Input formats The tool takes as input descriptions in .pnml (Petri Net Markup Language) and .net format (textual format for Petri nets described in the Tina man pages).\nThe path to the input Petri net must be specified using the -n \u0026lt;path\u0026gt; option.\nSMPT supports the verification of several kind of reachability properties on Petri nets.\nFor instance, the following call can be used to check for the existence of deadlocked states on model Kanban-00002.net.\n$ python3 -m smpt -n nets/Kanban/Kanban-00002.net --deadlock --methods BMC The tools also supports colored Petri nets. In this case, use the option --colored and install the mcc tool.\nThe tool supports three main kinds of properties:\nDetection of deadlocks, --deadlock: is there a reachable marking with no outgoing transitions. Quasi-liveness, --quasi-liveness t: is there a reachable marking where transition t can fire. You can check the quasi-liveness of several transitions at the same time by passing a comma-separated list of transition names: --quasi-liveness t1,...,tn. Reachability: --reachability p: is there a reachable marking where place p is marked (it has at least one token). You can check the reachability of several places at once by passing a comma-separated list of place names: --reachability p1,...,pn. The tool also supports properties from the MCC properties format by using the option --xml and indicating the path to the .xml properties file. At this time, the support is restricted to:\n--xml GlobalProperties.xml --xml ReachabilityCardinality.xml --xml ReachabilityFireability.xml Polyhedral reductions For methods that relies on polyhedral reductions, it is possible to automatically compute the reduction (--auto-reduce) or to provide a pre-computed version with option --reduce \u0026lt;path\u0026gt;. It is also possible to save a copy of the reduced net with the option --save-reduced-net \u0026lt;path\u0026gt;.\nSome examples of nets with their corresponding reductions are available in nets/E-Abstraction/.\nOutput format Results are printed in the text format required by the Model Checking Contest (MCC) which is of the form:\nFORMULA \u0026lt;id\u0026gt; (TRUE/FALSE) Some options permits to obtain more information:\n--verbose or -v: evolution of the methods --debug: input/output SMT-LIB exchanged with the SMT solver --show-techniques: returns the methods that successfully computed a verdict --show-time: print the execution time per property --show-reduction-ratio: get the reduction ratio --show-model: print the counterexample if it exists --check-proof: check the certificate of invariance (if we have one) --export-proof: export verdict certificates (inductive invariants (SMT-LIB), trace leading to counterexamples (.scn format), etc.) Verification methods The tool is composed of different methods:\nINDUCTION: a basic method that checks if a property is an inductive invariant. This property is easy to check, even though interesting properties are seldom inductive. BMC: Bounded Model Checking is an iterative method to explore the state space of systems by unrolling their transitions. This method is only useful for finding counterexamples. K-INDUCTION: is an extension of BMC that can also prove invariants. PDR-COV, PDR-REACH and PDR-REACH-SATURATED: Property Directed Reachability, also known as IC3, is a method to strengthen a property that is not inductive, into an inductive one. This method can return a verdict certificate. We provide three different methods of increasing complexity (cf. [TACAS2022]) (one for coverability and two for general reachability). STATE-EQUATION: is a method for checking that a property is true for all potentially reachable markings (solution of the state equation). We implement a refined version that can over-approximate the result with the help of trap constraints and other structural information, such as NUPN specifications. WALK: relies on simulation tools to quickly find counterexamples. We currently use walk that is distributed with the Tina toolbox. SMT and CP: are methods specific to SMPT in the case where nets are fully reducible (the reduced net has only one marking). In this case, reachable markings are exactly the solution of the reduction equations and verdicts are computed by solving linear system of equations. Depending on the input net, SMPT runs a subset of these methods in parallel.\nYou can restrict the choice of the verification methods with --methods \u0026lt;method_1\u0026gt; ... \u0026lt;methods_n\u0026gt;.\nThe --auto-enumerative and --enumerative \u0026lt;path\u0026gt; (where the path leads to the list of markings into the .aut format) perform an exhaustive exploration of the state space.\nTweaking options We provide a set of options to control the behavior of our verification jobs scheduler such as:\n--global-timeout \u0026lt;int\u0026gt;: add a timeout --timeout \u0026lt;int\u0026gt;: add a timeout per property --mcc: puts the tool in competition mode Usage You can list all the options by using the help option:\n$ python3 -m smpt --help usage: __main__.py [-h] [--version] [-v] [--debug] -n ptnet [--colored] [--xml PATH_PROPERTIES | --ltl-file PATH_LTL_FORMULA | --ltl LTL_FORMULA | --deadlock | --quasi-liveness QUASI_LIVE_TRANSITIONS | --reachability REACHABLE_PLACES] [--select-queries QUERIES] [--auto-reduce | --reduced PATH_PTNET_REDUCED] [--save-reduced-net] (--methods [{WALK,STATE-EQUATION,INDUCTION,BMC,K-INDUCTION,PDR-COV,PDR-REACH,PDR-REACH-SATURATED,SMT,CP,DUMMY} [{WALK,STATE-EQUATION,INDUCTION,BMC,K-INDUCTION,PDR-COV,PDR-REACH,PDR-REACH-SATURATED,SMT,CP,DUMMY} ...]] | --auto-enumerative | --enumerative PATH_MARKINGS) [--project] [--show-projection] [--save-projection PATH_PROJECTION_DIRECTORY] [--timeout TIMEOUT | --global-timeout GLOBAL_TIMEOUT] [--skip-non-monotonic] [--show-techniques] [--show-time] [--show-reduction-ratio] [--show-shadow-completeness] [--show-model] [--check-proof] [--export-proof PATH_PROOF] [--mcc] [--fireability] SMPT: Satisfiability Modulo Petri Net optional arguments: -h, --help show this help message and exit --version show the version number and exit -v, --verbose increase output verbosity --debug print the SMT-LIB input/output -n ptnet, --net ptnet path to Petri Net (.net or .pnml format) --colored colored input Petri net --xml PATH_PROPERTIES path to reachability formulas (.xml format) --ltl-file PATH_LTL_FORMULA path to reachability formula (.ltl format) --ltl LTL_FORMULA reachability formula (.ltl format) --deadlock deadlock analysis --quasi-liveness QUASI_LIVE_TRANSITIONS liveness analysis (comma separated list of transition names) --reachability REACHABLE_PLACES reachability analysis (comma separated list of place names) --select-queries QUERIES verify queries of a given comma-separated list --auto-reduce reduce automatically the Petri Net (using `reduce`) --reduced PATH_PTNET_REDUCED path to reduced Petri Net (.net format) --save-reduced-net save the reduced net --methods [{WALK,STATE-EQUATION,INDUCTION,BMC,K-INDUCTION,PDR-COV,PDR-REACH,PDR-REACH-SATURATED,SMT,CP,DUMMY} [{WALK,STATE-EQUATION,INDUCTION,BMC,K-INDUCTION,PDR-COV,PDR-REACH,PDR-REACH-SATURATED,SMT,CP,DUMMY} ...]] enable methods among WALK STATE-EQUATION INDUCTION BMC K-INDUCTION PDR-COV PDR-REACH PDR-REACH-SATURATED SMT CP DUMMY --auto-enumerative enumerate automatically the states (using `tina`) --enumerative PATH_MARKINGS path to the state-space (.aut format) --project Use TFG projection for WALK, BMC, K-INDUCTION, PDR, STATE-EQUATION --show-projection Show projected formulas --save-projection PATH_PROJECTION_DIRECTORY Save projected formulas --timeout TIMEOUT a limit per property on execution time --global-timeout GLOBAL_TIMEOUT a limit on execution time --skip-non-monotonic skip non-monotonic properties --show-techniques show the method returning the result --show-time show the execution time --show-reduction-ratio show the reduction ratio --show-shadow-completeness show the shadow completeness --show-model show a counterexample if there is one --check-proof check and show the certificate of invariance if there is one --export-proof PATH_PROOF export the proof of invariance if there is one --mcc Model Checking Contest mode --fireability Reachability Fireability mode (Cardinality by default) Model Checking Contest mode Disk images Complete installations of SMPT can be found in the MCC disk images (see the Tool Submission Kit for more information):\nMCC'2023: smpt-2023.tar.gz MCC'2022: smpt-2022.tar.gz MCC'2021: smpt-2021.vmdk.tar.gz You can also download the artifact of our [TACAS2022] paper that contains all the material to install the tool and reproduce the experiments:\nSMPT_TACAS_2022.zip Awards SMPT, won a bronze medal in the “reachability” category of the Model Checking Contest 2023, an international competition of model checking tools for the verification of concurrent systems.\nSMPT, won a bronze medal in the “reachability” category of the Model Checking Contest 2022. It also obtained the 100% confidence award.\nReferences Amat, N, Berthomieu, B, Dal Zilio, S. A Polyhedral Abstraction for Petri Nets and its Application to SMT-Based Model Checking. Fundamenta Informaticae (FI). 2022. Amat, N, Dal Zilio, S. SMPT: A Testbed for Reachability Methods in Generalized Petri Nets. Formal Methods (FM 2023). Amat, N, Dal Zilio, S, Hujsa, T. Property Directed Reachability for Generalized Petri Nets. Tools and Algorithms for the Construction and Analysis of Systems (TACAS). 2022. Amat, N, Berthomieu, B, Dal Zilio, S. On the Combination of Polyhedral Abstraction and SMT-Based Model Checking for Petri Nets. Application and Theory of Petri Nets and Concurrency (Petri Nets). 2021. F. Kordon and P. Bouvier and H. Garavel and F. Hulin-Hubard and N. Amat. and E. Amparore and B. Berthomieu and D Donatelli and S. Dal Zilio and P. G. Jensen and L. Jezequel and E. Paviot-Adet and J. Srba and Y. Thierry-Mieg. Complete Results for the 2023 Edition of the Model Checking Contest. 2023. F. Kordon and P. Bouvier and H. Garavel and F. Hulin-Hubard and N. Amat. and E. Amparore and B. Berthomieu and D. Donatelli and S. Dal Zilio and P. G. Jensen and L. Jezequel and C. He and S. Li and E. Paviot-Adet and J. Srba and Y. Thierry-Mieg. Complete Results for the 2022 Edition of the Model Checking Contest. 2022. F. Kordon and P. Bouvier and H. Garavel and L. M. Hillah and F. Hulin-Hubard and N. Amat. and E. Amparore and B. Berthomieu and S. Biswal and D. Donatelli and F. Galla and and S. Dal Zilio and P. G. Jensen and C. He and D. Le Botlan and S. Li and and J. Srba and . Thierry-Mieg and A. Walner and K. Wolf, Complete Results for the 2021 Edition of the Model Checking Contest. 2021. Dependencies The code repository includes copies of models taken from the MCC Petri Nets Repository located inside folder nets/.\nLicense This software is distributed under the GPLv3 license. A copy of the license agreement is found in the LICENSE file.\nAuthors Nicolas AMAT - LAAS/CNRS Bernard BERTHOMIEU - LAAS/CNRS Silvano DAL ZILIO - LAAS/CNRS Didier LE BOTLAN - LAAS/CNRS We are grateful to Yann THIERRY-MIEG for making MCC'2021 oracles available, and to the members of the Model Checking Contest committees.\n","date":1701648000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1701648000,"objectID":"ad31dc40bc1667c2c9bbf17f6d2d2c74","permalink":"https://nicolasAmat.github.io/project/smpt/","publishdate":"2023-12-04T00:00:00Z","relpermalink":"/project/smpt/","section":"project","summary":"An SMT-based model checker for Petri nets focused on reachability problems that takes advantage of polyhedral reduction.","tags":["Model Checking"],"title":"SMPT - Satisfiability Modulo Petri Nets","type":"project"},{"authors":null,"categories":null,"content":"About Octant is a pre-processor that can be used to accelerate the verification of generalized reachability properties on Petri nets. It takes advantage of structural reductions and work by projecting an initial reachability property into a simpler one, that can be checked on the reduced version of the Petri net.\nThe tool is named after the Octant map projection proposed by Leonardo da Vinci in 1508; the first known example of a polyhedral map projection.\nThis project was initially developed inside TiPX, a Petri net explorer.\nInstallation You can build an executable by compiling the project from its source, using the accompanying Makefile. The tool is written in OCaml and uses the Dune build system. You can also download the latest build of the tool, compiled for Linux, called octant.exe, on the \u0026ldquo;linux\u0026rdquo; branch of the repository\nRunning the tool ./octant.exe command1 command2 ... commandn Octant is a CLI tool that operates over its parameters as if they were a sequence of commands for a stack-based language. Each command takes its arguments from the stack and/or from the command-line.\np means \u0026lsquo;pop\u0026rsquo; (stack argument) r means \u0026lsquo;reads a command-line argument\u0026rsquo; 1 means pushes one value * means pushes multiple values Additionally, a global environment consists in bindings of the form\nname =\u0026gt; formula name =\u0026gt; bundle (that is: a Petri net, an initial marking, and possibly a tfg). Environment load : r -\u0026gt; 0 - (implicit) - Load the given Petri net, put it as a bundle in the environment with the name \u0026rsquo;net\u0026rsquo;. E.g.: load \u0026ldquo;file.net\u0026rdquo;.\nbind : rp -\u0026gt; 0 - Binds the element on the stack to the given name. E.g.: bind special-net.\nset : rp -\u0026gt; 0 - Synonym to bind.\nget : r -\u0026gt; 1 - (implicit) - Gets the element associated to the given identifier in the environment. Pushes it. E.g.: get special-net.\nFormulas form : r -\u0026gt; 1 - Parse and push the given formula(s) on the stack (as a list). The reference bundle is the last found in the environment.\nload-forms : r -\u0026gt; 1 - Read formulas from the given file and push them on the stack (as a list). The reference bundle is the last found in the environment.\nproject : p -\u0026gt; 1 - Projects a list of formulas (popped from the stack). The reference bundle must have a tfg. Pushes the resulting list of formulas.\ntproject : rp -\u0026gt; 1 - Projects with a time limit.\nDisplay quiet : -\u0026gt; 0 - Quiet mode (prints only necessary information, e.g. verdicts).\nsmt-format : -\u0026gt; 0 - Use smt-lib format when printing formulas.\nprint : p -\u0026gt; 0 - Pops and prints the topmost stack element.\nfprint : p -\u0026gt; 0 - Full print: print the topmost stack element, with details.\nnl : -\u0026gt; 0 - Prints a blank line (separator).\nOthers time : -\u0026gt; 0 - Prints the delay since the previous time command. The first time command does not print anything.\ndup : p -\u0026gt; 2 - Duplicate the argument on top of the stack.\npop : p -\u0026gt; 0 - Discards the topmost stack element.\nhelp : -\u0026gt; 0 - Display this help.\nReferences Amat, N, Le Botlan, D, Dal Zilio, S. Project and Conquer: Fast Quantifier Elimination for Checking Petri Nets Reachability. International Conference on Verification, Model Checking, and Abstract Interpretation (VMCAI), To appear. 2024. Dependencies The code repository includes OCaml libraries developed by Didier Le Botlan (outside this project) located inside folder lib/.\nLicense This software is distributed under the GPLv3 license.\nAuthors Nicolas Amat - LAAS/CNRS Didier Le Botlan - LAAS/CNRS ","date":1701561600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1701561600,"objectID":"57812b3c3d0f88b4e882698b02d28e90","permalink":"https://nicolasAmat.github.io/project/octant/","publishdate":"2023-12-03T00:00:00Z","relpermalink":"/project/octant/","section":"project","summary":"A tool to project Petri net reachability properties on reduced nets using polyhedral reduction.","tags":["Model Checking"],"title":"Octant - The Reachability Formula Projector","type":"project"},{"authors":null,"categories":null,"content":"About Kong is a tool to compute the concurrency relation of a Petri using net reduction. It also permits to compute the dead places and check if a given marking is reachable.\nFor more information about the usage and the compatible formats please refer to the tool paper published at Petri Nets 2022: Kong: a Tool to Squash Concurrent Places.\nRequirements Python \u0026gt;+ 3.5 caesar.bdd from the CADP Toolbox (only for the conc and dead subcommands) sift from the TINA Toolbox (only for the reach subcommand) reduce and ndrio tools from the TINA Toolbox (optional) graphviz python package Running the Tool Run Kong by selecting a subcommand (conc dead, or reach) and indicating the path to the input Petri net (.pnml or .nupn format):\n$\u0026gt; ./kong/kong.py {conc, dead, reach} {\u0026lt;path_to_.pnml\u0026gt;, \u0026lt;path_to_.nupn\u0026gt;} You can list all the subcommands by using the help option:\n$\u0026gt; ./kong/kong.py --help usage: kong.py [-h] [--version] {conc,dead,reach} ... Koncurrent places Grinder positional arguments: {conc,dead,reach} Mode conc Concurrent places computation dead Dead places computation reach Marking reachability decision options: -h, --help show this help message and exit --version show the version number and exit Similarly, you can list the options of each subcommand.\nconc:\n$\u0026gt; ./kong/kong.py conc --help usage: kong.py conc [-h] [-v] [-sk] [-sr | -rn REDUCED_NET] [-t] [-srr] [-se] [-dg] [-nu] [-nr] [-pl] [-sn] [--bdd-timeout BDD_TIMEOUT] [--bdd-iterations BDD_ITERATIONS] [-rm REDUCED_RESULT] [-srm] filename positional arguments: filename input Petri net (.pnml or .nupn format) options: -h, --help show this help message and exit -v, --verbose increase output verbosity -sk, --shrink use the Shrink reduction tool -sr, --save-reduced-net save the reduced net -rn REDUCED_NET, --reduced-net REDUCED_NET specify reduced Petri net (.net format) -t, --time show the computation time -srr, --show-reduction-ratio show the reduction ratio -se, --show-equations show the reduction equations -dg, --draw-graph draw the Token Flow Graph -nu, --no-units disable units propagation -nr, --no-rle disable run-length encoding (RLE) -pl, --place-names show place names -sn, --show-nupns show the NUPNs --bdd-timeout BDD_TIMEOUT set the time limit for marking graph exploration (caesar.bdd) --bdd-iterations BDD_ITERATIONS set the limit for number of iterations for marking graph exploration (caesar.bdd) -rm REDUCED_RESULT, --reduced-matrix REDUCED_RESULT specify reduced concurrency matrix (or dead places vector) file -srm, --show-reduced-matrix show the reduced matrix dead:\n$\u0026gt; ./kong/kong.py dead --help usage: kong.py dead [-h] [-v] [-sk] [-sr | -rn REDUCED_NET] [-t] [-srr] [-se] [-dg] [-nu] [-nr] [-pl] [-sn] [--bdd-timeout BDD_TIMEOUT] [--bdd-iterations BDD_ITERATIONS] [-rm REDUCED_RESULT] [-srv] filename positional arguments: filename input Petri net (.pnml or .nupn format) options: -h, --help show this help message and exit -v, --verbose increase output verbosity -sk, --shrink use the Shrink reduction tool -sr, --save-reduced-net save the reduced net -rn REDUCED_NET, --reduced-net REDUCED_NET specify reduced Petri net (.net format) -t, --time show the computation time -srr, --show-reduction-ratio show the reduction ratio -se, --show-equations show the reduction equations -dg, --draw-graph draw the Token Flow Graph -nu, --no-units disable units propagation -nr, --no-rle disable run-length encoding (RLE) -pl, --place-names show place names -sn, --show-nupns show the NUPNs --bdd-timeout BDD_TIMEOUT set the time limit for marking graph exploration (caesar.bdd) --bdd-iterations BDD_ITERATIONS set the limit for number of iterations for marking graph exploration (caesar.bdd) -rm REDUCED_RESULT, --reduced-vector REDUCED_RESULT specify reduced dead places vector file -srv, --show-reduced-vector show the reduced vector reach:\n$\u0026gt; ./kong.py reach --help usage: kong.py reach [-h] [-v] [-sk] [-sr | -rn REDUCED_NET] [-t] [-srr] [-se] [-dg] [-m MARKING] [-sf] filename positional arguments: filename input Petri net (.pnml or .net format) options: -h, --help show this help message and exit -v, --verbose increase output verbosity -sk, --shrink use the Shrink reduction tool -sr, --save-reduced-net save the reduced net -rn REDUCED_NET, --reduced-net REDUCED_NET specify reduced Petri net (.net format) -t, --time show the computation time -srr, --show-reduction-ratio show the reduction ratio -se, --show-equations show the reduction equations -dg, --draw-graph draw the Token Flow Graph -m MARKING, --marking MARKING marking -sf, --show-projected-marking show the projected marking Performance Evaluation The code repository includes a reproducible performance evaluation in the benchmark/ directory. (Jupyter notebook is required.)\nReferences Amat, N, Bouvier, P, Garavel, H. A Toolchain to Compute Concurrent Places of Petri Nets. Petri Nets and Other Models of Concurrency (ToPNoC), To appear. Amat, N, Dal Zilio, S, Le Botlan, D. Leveraging polyhedral reductions for solving Petri net reachability problems. International Journal on Software Tools for Technology Transfer (STTT). 2023. Amat, N, Chauvet, L. Kong: A Tool to Squash Concurrent Places. Application and Theory of Petri Nets and Concurrency (Petri Nets). 2022. Amat, N, Dal Zilio, S, Le Botlan, D. Accelerating the Computation of Dead and Concurrent Places Using Reductions. Model Checking Software (SPIN). 2021. Dependencies The code repository includes a link to models from the Model Checking Contest (MCC) used for benchmarking and continuous testing.\nLicense This software is distributed under the GPLv3 license. A copy of the license agreement is found in the LICENSE file.\nAuthors Nicolas AMAT - LAAS/CNRS ","date":1701475200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1701475200,"objectID":"ea75bec304f9f35be45330ff8815837a","permalink":"https://nicolasAmat.github.io/project/kong/","publishdate":"2023-12-02T00:00:00Z","relpermalink":"/project/kong/","section":"project","summary":"A tool to accelerate the computation of the concurrency relation of a Petri net using polyhedral reduction.","tags":["Model Checking"],"title":"Kong - The Koncurrent Places Grinder","type":"project"},{"authors":null,"categories":null,"content":"About Reductron is a tool that permits to prove that some parametric polyhedral equivalence, say $(N_1, C_1) \\approxeq_E (N_2, C_2)$, is correct. The tool relies on the tool FAST and the SMT solver z3.\nDependencies TaPAS - The Talence Presburger Arithmetic Suite FASTer - A tool for the analysis of large or even infinite systems ndrio from the TINA Toolbox - Petri nets converter z3 - SMT solver Installation The tool can be installed using pip:\n$ python setup.py bdist_wheel $ python -m pip install --user dist/reductron-1.0-py3-none-any.whl Note that the wheel package is required, you can install it using:\n$ pip3 install --user wheel Usage Examples of correct and incorrect polyhedral equivalences can be found in the rules/ directory.\nTo check an equivalence run:\n$ python3 -m reductron -i \u0026lt;initial.net\u0026gt; -r \u0026lt;reduced.net\u0026gt; You can list all the options by using the help option:\n$ python3 -m reductron -h usage: __main__.py [-h] [--version] [-v] [--debug] -i initial -r reduced [--show-time] Reductron - Automated Polyhedral Abstraction Prover options: -h, --help show this help message and exit --version show the version number and exit -v, --verbose increase output verbosity --debug print the SMT-LIB input/output -i initial, --initial-net initial path to the initial Petri Net (.net format) -r reduced, --reduced-net reduced path to the reduced Petri Net (.net format) --show-time show the execution time References Amat, N, Dal Zilio, S, Le Botlan, D. Automated Polyhedral Abstraction Proving. Application and Theory of Petri Nets and Concurrency (Petri Nets). 2023. License This software is distributed under the GPLv3 license. A copy of the license agreement is found in the LICENSE file.\nAuthors Nicolas AMAT - LAAS/CNRS ","date":1701388800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1701388800,"objectID":"eeb2de99fbdaae385c590cc71da06370","permalink":"https://nicolasAmat.github.io/project/reductron/","publishdate":"2023-12-01T00:00:00Z","relpermalink":"/project/reductron/","section":"project","summary":"A tool to automatically prove the correctness of polyhedral equivalences for Petri nets.","tags":["Model Checking"],"title":"Reductron - The Polyhedral Abstraction Prover","type":"project"},{"authors":[],"categories":null,"content":"","date":1698105600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1698105600,"objectID":"44d8a4d51ae8073962530983d30b8999","permalink":"https://nicolasAmat.github.io/talk/m2f_seminar_2023/","publishdate":"2022-07-07T00:00:00Z","relpermalink":"/talk/m2f_seminar_2023/","section":"talk","summary":"Seminar: MTV at LaBRI","tags":[],"title":"Automated Proof of Polyhedral Abstraction for Petri Nets","type":"talk"},{"authors":["Nicolas Amat","Pierre Bouvier","Hubert Garavel"],"categories":null,"content":"","date":1693526400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1693526400,"objectID":"2b36658f3d87e37d423f4d9b6be5835b","permalink":"https://nicolasAmat.github.io/publication/topnoc/","publishdate":"2023-07-01T00:00:00Z","relpermalink":"/publication/topnoc/","section":"publication","summary":"The concurrent places of a Petri net are all pairs of places that may simultaneously have a token in some reachable marking. Concurrent places generalize the usual notion of dead places and are particularly useful for decomposing a Petri net into synchronized automata executing in parallel. We present a state-of-the-art toolchain to compute the concurrent places of a Petri net. This is achieved by a rich combination of various techniques, including: state-space exploration using BDDs, structural rules for concurrent places, quadratic over- and under-approximation of reachable markings, and polyhedral abstraction of the state space based on structural reductions and linear arithmetic constraints on markings. We assess the performance of our toolchain on a large collection of 850 nets originating from the 2022 edition of the Model Checking Contest.","tags":["Nested-unit Petri nets","Model checking","Reachability problems","Concurrency theory","Abstraction techniques","Structural reductions","State-space exploration"],"title":"A Toolchain to Compute Concurrent Places of Petri Nets","type":"publication"},{"authors":[],"categories":null,"content":"","date":1687219200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1687219200,"objectID":"c293268aebcb1003014f29469fc3ccfc","permalink":"https://nicolasAmat.github.io/talk/imdea_2023/","publishdate":"2023-06-20T00:00:00Z","relpermalink":"/talk/imdea_2023/","section":"talk","summary":"Invited Talk at IMDEA Software Institute","tags":[],"title":"What is polyhedral reduction? ...and how we use it to accelerate the verification of reachability problems for Petri nets.","type":"talk"},{"authors":["Nicolas Amat","Silvano Dal Zilio","Didier Le Botlan"],"categories":null,"content":"","date":1685145600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1685145600,"objectID":"494e13d0585224966d13eb6a618acc92","permalink":"https://nicolasAmat.github.io/publication/petri_nets_2023/","publishdate":"2023-05-27T00:00:00Z","relpermalink":"/publication/petri_nets_2023/","section":"publication","summary":"We propose an automated procedure to prove polyhedral abstractions for Petri nets. Polyhedral abstraction is a new type of state-space equivalence based on the use of linear integer constraints. Our approach relies on an encoding into a set of SMT formulas whose satisfaction implies that the equivalence holds. The difficulty, in this context, arises from the fact that we need to handle infinite-state systems. For completeness, we exploit a connection with a class of Petri nets that have Presburger-definable reachability sets. We have implemented our procedure, and we illustrate its use on several examples.","tags":["Automated reasoning","Abstraction techniques","Reachability problems","Petri nets"],"title":"Automated Polyhedral Abstraction Proving","type":"publication"},{"authors":[],"categories":null,"content":"","date":1681171200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1681171200,"objectID":"c90296a19cfb5387e9ce7da2ebd42919","permalink":"https://nicolasAmat.github.io/talk/afsec_2023/","publishdate":"2023-04-11T00:00:00Z","relpermalink":"/talk/afsec_2023/","section":"talk","summary":"Invited Presentation: AFSEC 2023","tags":[],"title":"Computing Linear Inductive Invariants for Petri Nets using Property Directed Reachability","type":"talk"},{"authors":[],"categories":null,"content":"","date":1680652800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1680652800,"objectID":"c306685a900955c055ef550c626d0c7b","permalink":"https://nicolasAmat.github.io/talk/fac_2023/","publishdate":"2023-04-05T00:00:00Z","relpermalink":"/talk/fac_2023/","section":"talk","summary":"Presentation: Journées FAC 2023","tags":[],"title":"Property Directed Reachability for Generalized Petri Nets","type":"talk"},{"authors":["Nicolas Amat","Silvano Dal Zilio"],"categories":null,"content":"","date":1677801600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1677801600,"objectID":"52e3a63180bf471ef97ce77663edf9c8","permalink":"https://nicolasAmat.github.io/publication/fm_2023/","publishdate":"2023-03-03T00:00:00Z","relpermalink":"/publication/fm_2023/","section":"publication","summary":"SMPT (for Satisfiability Modulo Petri Net) is a model checker for reachability problems in Petri nets. It started as a portfolio of methods to experiment with symbolic model checking, and was designed to be easily extended. Some distinctive features are its ability to benefit from structural reductions and to generate verdict certificates. Our tool is quite mature and performed well compared to other state-of-the-art tools in the Model Checking Contest.","tags":["Model Checking","Reachability problem","Petri nets"],"title":"SMPT: A Testbed for Reachability Methods in Generalized Petri Nets","type":"publication"},{"authors":["Nicolas Amat","Silvano Dal Zilio","Didier Le Botlan"],"categories":null,"content":"","date":1671667200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1671667200,"objectID":"e9e59abd9e85dc1e8b2b3f30a339219b","permalink":"https://nicolasAmat.github.io/publication/sttt/","publishdate":"2022-12-22T00:00:00Z","relpermalink":"/publication/sttt/","section":"publication","summary":"We propose a new method that takes advantage of structural reductions to accelerate the verification of reachability properties on Petri nets. Our approach relies on a state space abstraction, called polyhedral abstraction, which involves a combination between structural reductions and sets of linear arithmetic constraints between the marking of places. We propose a new data structure, called a Token Flow Graph (TFG), that captures the particular structure of constraints occurring in polyhedral abstractions. We leverage TFGs to efficiently solve two reachability problems: first to check the reachability of a given marking and then to compute the concurrency relation of a net, that is, all pairs of places that can be marked together in some reachable marking. Our algorithms are implemented in a tool, called Kong, that we evaluate on a large collection of models used during the 2020 edition of the Model Checking Contest. Our experiments show that the approach works well, even when a moderate amount of reductions applies.","tags":["Petri nets","Structural reductions","Reachability","Concurrent places"],"title":"Leveraging polyhedral reductions for solving Petri net reachability problems","type":"publication"},{"authors":["Nicolas Amat","Bernard Berthomieu","Silvano Dal Zilio"],"categories":null,"content":"","date":1666569600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1666569600,"objectID":"9daee33bd9e5895cc9f4366d8e086c9a","permalink":"https://nicolasAmat.github.io/publication/fi/","publishdate":"2022-10-24T00:00:00Z","relpermalink":"/publication/fi/","section":"publication","summary":"We define a new method for taking advantage of net reductions in combination with a SMT-based model checker. Our approach consists in transforming a reachability problem about some Petri net, into the verification of an updated reachability property on a reduced version of this net. This method relies on a new state space abstraction based on systems of constraints, called polyhedral abstraction. We prove the correctness of this method using a new notion of equivalence between nets. We provide a complete framework to define and check the correctness of equivalence judgements; prove that this relation is a congruence; and give examples of basic equivalence relations that derive from structural reductions. Our approach has been implemented in a tool, named SMPT, that provides two main procedures: Bounded Model Checking (BMC) and Property Directed Reachability (PDR). Each procedure has been adapted in order to use reductions and to work with arbitrary Petri nets. We tested SMPT on a large collection of queries used in the Model Checking Contest. Our experimental results show that our approach works well, even when we only have a moderate amount of reductions.","tags":["Petri nets","Model Checking","Reachability","SMT solving","Abstraction techniques"],"title":"A Polyhedral Abstraction for Petri nets and its Application to SMT-Based Model Checking","type":"publication"},{"authors":[],"categories":null,"content":"","date":1657584000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657584000,"objectID":"2ccdbb72f874fe5b91beaf8054cf9d8e","permalink":"https://nicolasAmat.github.io/talk/gt_verif_2022/","publishdate":"2022-07-12T00:00:00Z","relpermalink":"/talk/gt_verif_2022/","section":"talk","summary":"Presentation: GT VERIF 2022","tags":[],"title":"Computing Linear Inductive Invariants for Petri Nets using Property Directed Reachability","type":"talk"},{"authors":[],"categories":null,"content":"","date":1657152000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1657152000,"objectID":"e1416f7bfdb6849f63d6c6cbceb4eea3","permalink":"https://nicolasAmat.github.io/talk/mtv_seminar_2022/","publishdate":"2022-07-07T00:00:00Z","relpermalink":"/talk/mtv_seminar_2022/","section":"talk","summary":"Seminar: MTV at LaBRI","tags":[],"title":"What is Polyhedral Reduction? ... and how we use it to accelerate the verification of reachability problems","type":"talk"},{"authors":["Nicolas Amat","Louis Chauvet"],"categories":null,"content":"","date":1655856000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1655856000,"objectID":"183346c7694453cda0df2f1f9939b6b2","permalink":"https://nicolasAmat.github.io/publication/petri_nets_2022/","publishdate":"2021-06-22T00:00:00Z","relpermalink":"/publication/petri_nets_2022/","section":"publication","summary":"Kong, the Koncurrent places Grinder, is a tool designed to compute the concurrency relation of a Petri net by taking advantage of structural reductions. The specificity of Kong is to rely on a state space abstraction, called polyhedral abstraction in previous works, that involves a combination of structural reductions and linear arithmetic constraints between the marking of places.","tags":["Petri nets","Abstraction techniques","Reachability problems"],"title":"Kong: a Tool to Squash Concurrent Places","type":"publication"},{"authors":["Nicolas Amat","Silvano Dal Zilio","Thomas Hujsa"],"categories":null,"content":"","date":1649203200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1649203200,"objectID":"ced012a7f0f2723c5e17b4814e139a86","permalink":"https://nicolasAmat.github.io/publication/tacas_2022/","publishdate":"2022-04-06T00:00:00Z","relpermalink":"/publication/tacas_2022/","section":"publication","summary":"We propose a semi-decision procedure for checking generalized reachability properties, on generalized Petri nets, that is based on the Property Directed Reachability (PDR) method. We actually define three different versions, that vary depending on the method used for abstracting possible witnesses, and that are able to handle problems of increasing difficulty. We have implemented our methods in a model-checker called SMPT and give empirical evidences that our approach can handle problems that are difficult or impossible to check with current state of the art tools.","tags":["Petri nets","Model Checking","Reachability","SMT solving"],"title":"Property Directed Reachability for Generalized Petri Nets","type":"publication"},{"authors":[],"categories":null,"content":"","date":1634256000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1634256000,"objectID":"9a069ee27e7fbc430f3c1c9a01ee6835","permalink":"https://nicolasAmat.github.io/talk/fac_2021/","publishdate":"2021-10-15T00:00:00Z","relpermalink":"/talk/fac_2021/","section":"talk","summary":"Presentation: Journées FAC 2021","tags":[],"title":"On the Combination of Polyhedral Abstraction and SMT-Based Model Checking for Petri Nets","type":"talk"},{"authors":["Nicolas Amat","Silvano Dal Zilio","Didier Le Botlan"],"categories":null,"content":"","date":1626048000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1626048000,"objectID":"3f5b6e17b8343fe40adce4b03c3edbe6","permalink":"https://nicolasAmat.github.io/publication/spin_2021/","publishdate":"2021-07-12T00:00:00Z","relpermalink":"/publication/spin_2021/","section":"publication","summary":"We propose a new method for accelerating the computation of a concurrency relation, that is all pairs of places in a Petri net that can be marked together. Our approach relies on a state space abstraction, that involves a mix between structural reductions and linear algebra, and a new data-structure that is specifically designed for our task. Our algorithms are implemented in a tool, called Kong, that we test on a large collection of models used during the 2020 edition of the Model Checking Contest. Our experiments show that the approach works well, even when a moderate amount of reductions applies.","tags":["Petri Nets","Concurrent Places","Structural Reductions"],"title":"Accelerating the Computation of Dead and Concurrent Places Using Reductions","type":"publication"},{"authors":["Nicolas Amat","Bernard Berthomieu","Silvano Dal Zilio"],"categories":null,"content":"","date":1624492800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1624492800,"objectID":"ce04df48247c624e092683b1bb210347","permalink":"https://nicolasAmat.github.io/publication/petri_nets_2021/","publishdate":"2021-06-24T00:00:00Z","relpermalink":"/publication/petri_nets_2021/","section":"publication","summary":"We define a method for taking advantage of net reductions in combination with a SMT-based model checker. We prove the correctness of this method using a new notion of equivalence between nets that we call polyhedral abstraction. Our approach has been implemented in a tool, named SMPT, that provides two main procedures: Bounded Model Checking (BMC) and Property Directed Reachability (PDR). Each procedure has been adapted in order to use reductions and to work with arbitrary Petri nets. We tested SMPT on a large collection of queries used during the 2020 edition of the Model Checking Contest. Our experimental results show that our approach works well, even when we only have a moderate amount of reductions.","tags":["Model Checking","Reachability problems","SMT solving","Abstraction techniques"],"title":"On the Combination of Polyhedral Abstraction and SMT-Based Model Checking for Petri Nets","type":"publication"},{"authors":[],"categories":null,"content":"","date":1623801600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1623801600,"objectID":"0df988aedcb3df765a37c3d929dd61c6","permalink":"https://nicolasAmat.github.io/talk/afsec_2021/","publishdate":"2021-06-16T00:00:00Z","relpermalink":"/talk/afsec_2021/","section":"talk","summary":"Invited Presentation: AFSEC 2021","tags":[],"title":"Une approche polyédrique pour la vérification SMT de réseaux de Petri","type":"talk"},{"authors":["Nicolas Amat"],"categories":null,"content":"","date":1590969600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1590969600,"objectID":"e263caec786ff324a7026473c6e2e951","permalink":"https://nicolasAmat.github.io/publication/amat_master_thesis/","publishdate":"2020-06-01T00:00:00Z","relpermalink":"/publication/amat_master_thesis/","section":"publication","summary":"The Vertics team at LAAS-CNRS has been developing a new approach for the symbolic model checking for years, i.e., a method to represent exactly the state-space of a system without enumerating it exhaustively. This study's originality consists in the verification of properties on a Petri net $N$ from a reduced net $N'$, as well as a system of linear equations $E$ linking these two nets. This study focuses on the adaptation of SAT methods such as BMC and PDR into SMT methods to verify efficiently different properties on non-safe Petri nets by taking advantage of these nets reductions. After defining the reductions used, this study defines a new notion of equivalence to prove the soundness of these reduction rules. This study is also interested in the decomposition of Petri nets into sub-net called NUPNs, introduced by the Convecs team from INRIA. This decomposition requires the computation of concurrency relations between the places composing the net. This work proposes a promising method to answer this question on large nets by treating the reduction equations.","tags":[],"title":"Master thesis: A New Approach for the Symbolic Model Checking of Petri nets","type":"publication"},{"authors":null,"categories":null,"content":"Formalization of separation logic using the Isabelle/HOL proof assistant, as well as the proof of formula rewriting results from a paper entitled “The Bernays-Schönfinkel-Ramsey Class of Separation Logic on Arbitrary Domains”.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"eadc10742356f2b8637ab015398f5285","permalink":"https://nicolasAmat.github.io/project/sepration_logic_formalization/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/project/sepration_logic_formalization/","section":"project","summary":"Formalization of separation logic using the Isabelle/HOL proof assistant, as well as the proof of formula rewriting results from a paper entitled “The Bernays-Schönfinkel-Ramsey Class of Separation Logic on Arbitrary Domains”.","tags":["Other"],"title":"Separation Logic Formalization","type":"project"},{"authors":null,"categories":null,"content":"The goal of this project is to showcase the application of SMT (Satisfiability Modulo Theories) methods in system verification by developing a Petri net model checker that solves the reachability problem. As a developer, you will have the opportunity to participate in the reachability category of the Model Checking Contest, an international competition for model checking tools, and put your skills to the test.\n1 - Theoretical Background We start by introducing some key concepts that are useful in the context of this project.\n1.1 - Model Checking Overview Model Checking is a formal method for checking whether a model of a system meets a given specification. A (property) specification describes the properties of interest, like for instance the states or events that are forbidden. A model defines the idealized behavior of the system and how it interacts with the external world. This technique can be used at different stages of systems development (design, architecture, etc.) and, in its simplest form, can be described as an exhaustive exploration of all the states that the system can take. In this project, we focus on reachability properties (sometimes also called safety properties), meaning properties about the states that the system can reach.\nModel Checking is composed of three main elements to perform verification:\nA property specification language, that is a formalism to describe the properties. Different temporal logics can be used, such as LTL (Linear Temporal Logic) or CTL (Computation Tree Logic). A behavioral specification language, that is a formalism to describe the system and its behavior. A model-checker can work with different formalisms, such as networks of automata, process calculi, Petri net, and many others. A verification technique, that is a method to prove that the system satisfies the given properties or return a counter-example if it is not the case. Besides \u0026ldquo;traditional\u0026rdquo; enumerative or automata-based techniques, two main approaches can be found: a first one based on the use of decision diagrams (such as Binary Decision Diagrams); and a second one based on an encoding into a SAT problem. 1.2 - Petri Nets Petri nets, also called Place/Transition (P/T) nets, are a mathematical model of concurrent systems defined by Carl Adam Petri. The idea is to describe the state of a system using places, containing tokens. A change of state of the system is represented by transitions. Places are connected to transitions by arcs. If a condition on the number of tokens in the inputs places is met, the transition can fire, in this case some tokens are removed from the input places, and some are added to the output places. Basically, places are a representation of the states, conditions, and resources of a system, while transitions symbolize actions. A complete formalization of Petri nets can be found in [Murata, 1989]; see also the online resources at the Petri Nets world.\n1.2.1 - Syntax A Petri net $N$ is a 4-tuple $(P, T, \\mathrm{Pre}, \\mathrm{Post})$ where:\n$P = {p_1, \\dots, p_n}$ is a finite set of places, $T = {t_1, \\dots, t_k}$ is a finite set of transitions disjoint from the set of places $(P \\cap T = \\emptyset)$, $\\mathrm{Pre} : T \\rightarrow (P \\rightarrow \\mathbb{N})$ is the pre-condition function, $\\mathrm{Post} : T \\rightarrow (P \\rightarrow \\mathbb{N})$ is the post-condition function. 1.2.2 - Useful Notations The pre-set of a transition $t \\in T$ is denoted ${}^{\\bullet} t = {p \\in P \\mid \\mathrm{Pre}(t,p) \u0026gt; 0 }$. Symetrically, the post-set of a transition $t$ is denoted $t^{\\bullet} = { p \\in P \\mid \\mathrm{Post}(t,p) \u0026gt; 0 }$. The mappings $\\mathrm{Pre}(t,p)$ and $\\mathrm{Post}(t,p)$ define the weight of arcs between $p$ and $t$. A Petri net is called ordinary when the (non-zero) weights on all arcs are equal to $1$.\nThese notations can be extended to the pre-set and post-set of a place $p$, with ${}^{\\bullet} p = { t \\in T \\mid \\mathrm{Post} (t,p) \u0026gt; 0 }$ and $p^{\\bullet} = { t \\in T \\mid \\mathrm{Pre}(t,p) \u0026gt; 0 }$.\nGiven a set of constants $A$, we define the set of finite sequences on $A$ to be the free monoid $A^\\star$, where $\\epsilon$ stands for the \u0026ldquo;empty sequence\u0026rdquo;. We will use $s \\cdot s\u0026rsquo;$ for the concatenation operation between sequences, that we should often write $s, s\u0026rsquo;$.\n1.2.3 - Markings and Reachability Set A marking of a Petri net $(P, T, \\mathrm{Pre}, \\mathrm{Post})$ is a mapping $m : P \\rightarrow \\mathbb{N}$, which assigns a number of tokens to each place. Hence $m(p)$ is the number of tokens for place $p$ in $m$. We say that $m$ is a marking over $N$, or even simply a marking over $P$.\nA marked Petri net is a tuple $(N, m_0)$ where $N$ is a Petri net and $m_0$ is the initial marking.\nA transition $t \\in T$ is fireable or enabled in a marking $m \\in \\mathbb{N}^P$, denoted $m \\xrightarrow{t}$, if and only if $m(p) \\ge \\mathrm{Pre}(t,p)$ for all place $p$ in ${}^{\\bullet}t$.\nA marking $m\u0026rsquo; \\in \\mathbb{N}^P$ is reachable from a marking $m \\in \\mathbb{N}^P$ by firing transition $t$, denoted $m \\xrightarrow{t} m\u0026rsquo;$, if: (1) transition $t$ is enabled at $m$; and (2) for all place $p$ in P, we have $m\u0026rsquo;(p) = m(p) - \\mathrm{Pre}(t,p) + \\mathrm{Post}(t,p)$.\nWe say that a firing sequence $\\sigma = t_1, \\dots, t_n \\in T^*$ can be fired from an initial marking $m_0$, denoted $m_0 \\xrightarrow{\\sigma} m$, if there exists markings $m_1, \\dots, m_n$ such that $m = m_n$ and $m_i \\xrightarrow{t_{i+1}}m_{i+1}$ for all $i \\in 1..n$. We denote $R(N, m_0)$ the set of markings reachable from $m_0$ in the net $N$.\n1.2.4 - Classification: Safe Nets A marked Petri net $(N, m_0)$ is called safe when, for all reachable marking $m$ (in $R(N, m_0)$) we have $m(p) \\le 1$ for all places $p$ in $P$. In other words, for all reachable markings, the marking of a place is always bounded by $1$.\n1.2.5 - Graphical syntax A Petri net can be represented graphically: places are represented by circles, transitions by squares, and arcs by arrows. Black dots inside a place are used to represent tokens in the marking of a place. In our example, transition $t_0$ is fireable, because place $p_0$ has a token.\n1.3 - Reachability Formulas We are interested in the verification of safety properties over the reachable markings of a marked net $(N, m_0)$, with set of places $P$. Given a formula $F$ with variables in $P$, we say that $F$ is reachable if there exists at least one reachable marking, $m \\in R(N, m_0)$, such that $m \\models F$. We call such marking a witness of $F$. Conversly, a formula $G$ is said invariant if it holds on all the reachable markings of $(N, m_0)$ (or, equivalently, if $\\neg G$ is not reachable). Example of properties we can express in this way include: checking if some transition $t$ is enabled (commonly known as quasi-liveness); checking if there is a deadlock; checking whether some linear invariant between places is always true; etc.\n2. Instructions In the usmpt/ directory you will find all the Python code to build your own model-checker. The parsers and data-structure are already written. Of course, you can modify any part of the code if you feel the need.\n2.1 - Running the Tool The tool must be runned as a Python package, using the command python3 -m usmpt. Option --help will output how to use it:\n$ python3 -m usmpt --help usage: __main__.py [-h] [--version] [-v] [--debug] -n ptnet (-ff PATH_FORMULA | -f FORMULA) --methods [{STATE-EQUATION,INDUCTION,BMC,K-INDUCTION,DUMMY} ...] [--timeout TIMEOUT] [--show-time] [--show-model] uSMPT: An environnement to experiment with SMT-based model checking for Petri nets options: -h, --help show this help message and exit --version show the version number and exit -v, --verbose increase output verbosity --debug print the SMT-LIB input/output -n ptnet, --net ptnet path to Petri Net (.net format) -ff PATH_FORMULA, --formula-file PATH_FORMULA path to reachability formula -f FORMULA, --formula FORMULA reachability formula --methods [{STATE-EQUATION,INDUCTION,BMC,K-INDUCTION,DUMMY} ...] enable methods among STATE-EQUATION INDUCTION BMC K-INDUCTION DUMMY --timeout TIMEOUT a limit on execution time --show-time show the execution time Basically, usmpt takes as input a Petri net in the .net format (see documentation), and a formula defined using the following syntax:\n\u0026lt;expression\u0026gt; ::= \u0026quot;T\u0026quot; (true) | \u0026quot;F\u0026quot; (false) | \u0026lt;atom\u0026gt; | - \u0026lt;expression\u0026gt; (logic negation) | \u0026lt;expression\u0026gt; /\\ \u0026lt;expression\u0026gt; (conjunction) | \u0026lt;expression\u0026gt; \\/ \u0026lt;expression\u0026gt; (conjunction) \u0026lt;atom\u0026gt; ::= \u0026lt;atom\u0026gt; \u0026lt;comparison\u0026gt; \u0026lt;atom\u0026gt; \u0026lt;member\u0026gt; ::= \u0026lt;integer\u0026gt; | \u0026lt;place-identifier\u0026gt; | \u0026lt;integer\u0026gt; \u0026quot;*\u0026quot; \u0026lt;place-identifier\u0026gt; | \u0026lt;member\u0026gt; + \u0026lt;member\u0026gt; \u0026lt;integer\u0026gt; ::= [0-9]+ \u0026lt;comparison\u0026gt; ::= \u0026quot;\u0026lt;=\u0026quot; | \u0026quot;\u0026gt;=\u0026quot; | \u0026quot;\u0026gt;\u0026quot; | \u0026quot;\u0026lt;\u0026quot; | \u0026quot;=\u0026quot; | \u0026quot;!=\u0026quot; When dealing with formulas on safe nets, we restrict the comparison operators to = and != and the semantics of + corresponds to the logical or, 1 to T and 0 to F.\nYou will find some examples of nets and formulas in the nets/ directory, and their graphical representation in the pics/ directory. You can draw, edit and play with the net using the nd editor from the Tina toolbox.\nRunning python3 -m usmpt -n \u0026lt;path_net\u0026gt; -ff \u0026lt;path_formula\u0026gt; -v --methods DUMMY will output the net and the formula (--methods DUMMY permits to do not select any method).\nMore generally, the files in the project are organized as follow; only the files with an asterisk (*) are intended to be modified:\nusmpt/ smpt.py # main script ptio/ ptnet.py # Petri net module (*) formula.py # Formula module (*) verdict.py # Verdict module checkers/ abstractchecker.py # abstract class of model checking methods bmc.py # template for the Bounded Model Checking method (*) induction.py # template for the inductive method (*) kinduction.py # template for the k-induction method (*) stateequation.py # template for the state-equation method (*) interfaces/ solver.py # abstract class for solver interface z3.py # interface to the z3 solver exec/ parallelizer.py # module to manage the parallel execution of methods utils.py # some utils for managing process and verbosity During the project you can use any SAT/SMT solver. However, usmpt already provides an interface with the z3 solver, using the SMT-LIB format. You will find documentation at the end of this file in Appendix.\n2.2 - Defining Predicates We start by defining a few formulas (on paper first) that ease the subsequent expression of model checking procedures. This will help you with the most delicate point of our encoding, which relies on how to encode sequences of transitions.\nIn the following, we use $\\vec{x}$ for the vector of variables $(x_1, \\dots, x_n)$, corresponding to the places $p_1, \\dots, p_n$ of $P$, and $F(\\vec{x})$ for a formula whose variables are included in $\\vec{x}$. We say that a mapping[^1] $m$ of $\\mathbb{N}^{P}$ is a model of $F$, denoted $m \\models F$, if the ground formula $F(m) = F(m(p_1), \\dots, m(p_n))$ is true. Hence, we can also interpret $F$ as a predicate over markings.\nWe start by considering that nets are safe. Hence we can work with Boolean variables (a place contains one token or not), and thus Boolean predicates.\n❓ Define the predicate $\\underline{m}(\\vec{x})$, given a marking $m$, which models exactly $m$ (this predicate admits only one model that is $m$).\n❓ Define the predicate $\\mathrm{ENBL}_t(\\vec{x})$, given a transition $t$, which models exactly the markings that enable $t$.\nFor the following question, you can define another helper predicate, $\\Delta_t(\\vec{x}, \\vec{x\u0026rsquo;})$ encoding the token displacement from $\\vec{x}$ to $\\vec{x}\u0026rsquo;$ by firing some transition $t$.\n❓ Define a predicate $\\mathrm{T}(\\vec{x}, \\vec{x}\u0026rsquo;)$ that describes the relation between the markings before $(\\vec{x})$ and after $(\\vec{x\u0026rsquo;})$ firing a transition. With this convention, formula $\\mathrm{T}(\\vec{x}, \\vec{x}\u0026rsquo;)$ holds if and only if $x \\xrightarrow{t} x\u0026rsquo;$ holds for some transition $t$.\n2.3 - Implementing SMT-based model checking methods Our next step is to implement some model checking methods that will make use of the predicate $\\mathrm{T}(\\vec{x}, \\vec{x}\u0026rsquo;)$. To define multiple vectors of variables, namely $\\vec{x^0}, \\vec{x^1}, \\vec{x^2}$, we suggest using @k as a suffix for each place identifier. It is important to note that the k parameter is already an argument of the different smtlib methods.\n2.3.1 - Bounded Model Checking (BMC) The Bounded Model Checking analysis method, or BMC for short, is an iterative method exploring the state-space of finite-state systems by unrolling their transitions [Biere et al., 1999]. The method was originally based on an encoding of transition systems into (a family of) propositional logic formulas and the use of SAT solvers to check these formulas for satisfiability. More recently, this approach was extended to more expressive models, and richer theories, using SMT solvers.\nIn BMC, we try to find a reachable marking $m$ that is a model for a given formula $F$. The algorithm starts by computing a formula, say $\\phi_0$, representing the initial marking (hence $\\phi_0 \\triangleq \\underline{m_0}$) and checking whether $\\phi_0 \\land F$ is satisfiable (meaning $F$ is initially true). If the formula is UNSAT, we compute a formula $\\phi_1$ representing all the markings reachable in one step, or less, from the initial marking and check $\\phi_1 \\land F$. This way, we compute a sequence of formulas $(\\phi_i){i \\in \\mathbb{N}}$ until either $\\phi_i \\land F$ is SAT (in which case a witness is found) or we have $\\phi{i+1} \\Rightarrow \\phi_i$ (in which case we reach a fixpoint and no counter-example exists).\nThe BMC method is not complete since it is not possible, in general, to bound the number of iterations needed to give an answer. Also, when the net is unbounded, we may very well have an infinite sequence of formulas $\\phi_0 \\subsetneq \\phi_1 \\subsetneq \\dots$ However, in practice, this method can be very efficient to find a witness when it exists.\nThe crux of the method is to compute formulas $\\phi_i$ that represents the set of markings reachable using firing sequences of length at most $i$. Your goal is to build such formulas incrementally.\n❓ Implement the prove_helper(self) -\u0026gt; int method of the BMC class that returns the iteration index if a witness is found.\nNote that to run BMC you must select it using --methods BMC.\nWe give, below, a brief pseudocode description of the algorithm.\nx \u0026lt;- freshVariables() phi \u0026lt;- m0(x) while unsat(phi /\\ F(x)) { x' \u0026lt;- freshVariables() phi \u0026lt;- phi /\\ T(x, x') x \u0026lt;- x' } return T 2.3.2 - Induction Induction is a basic method that checks if a property is an inductive invariant. This property is \u0026ldquo;easy” to check, even though interesting properties are seldom inductive.\nTo prove that property $F$ is not reachable (no reachable state satisfies $F$), it is sufficient to prove that $\\neg F$ is inductive, or equivalently that the following two properties hold:\n$\\underline{m_0}(\\vec{x}) \\land F(\\vec{x})$ is UNSAT; and $\\neg F(\\vec{x}) \\land T(\\vec{x}, \\vec{x\u0026rsquo;}) \\land F(\\vec{x\u0026rsquo;})$ is UNSAT. Note that checking condition (2) is equivalent to proving that $\\left ( \\neg F(\\vec{x}) \\land T(\\vec{x}, \\vec{x}\u0026rsquo;) \\right) \\Rightarrow \\neg F(\\vec{x}\u0026rsquo;)$ is a tautology.\n❓ Implement the prove_helper(self) -\u0026gt; Optional[bool] method of the Induction class that returns True if constraint (1) is SAT (i.e. the initial marking is a model of $F$); returns False if both constraints (1) and (2) are UNSAT (i.e. $\\neg F$ is an invariant); and returns None otherwise.\n2.3.3 - K-Induction K-Induction is an extension of the BMC and Induction methods, that can also prove that a formula is not reachable [Sheeran et al., 2000]. Sometimes, $\\neg F$ may not be inductive by unrolling only one transition (and so the Induction method will return None).\nThe algorithm starts by computing a formula $\\psi_0(\\vec{x_0}, \\vec{x_1}) \\triangleq \\neg F(\\vec{x_0}) \\land T(\\vec{x_0}, \\vec{x_1})$, and check whether $\\psi_0(\\vec{x_0}, \\vec{x_1}) \\land F(\\vec{x_1})$ is UNSAT or not. If it is UNSAT, we must ensure that the first iteration (i = 0) of BMC does not find a witness. If not, we proved that $\\neg F$ is an invariant with exactly the same queries as the induction method. In the other case, if $\\psi_0(\\vec{x_0}, \\vec{x_1}) \\land F(\\vec{x_1})$ is SAT, we continue by unrolling the transitions and computing a formula $\\psi_1$ representing the states reachable by firing two transitions consecutively from $\\neg F$ as : $\\psi_1(\\vec{x_0}, \\vec{x_1}, \\vec{x_2}) \\triangleq \\psi_0(\\vec{x_0}, \\vec{x_1}) \\land \\neg F(\\vec{x_1}) \\land T(\\vec{x_1}, \\vec{x_2})$ and check whether $\\psi_1 \\land F(\\vec{x_2})$ is UNSAT or not.\nThe interconnection between BMC and KInduction is already implemented in usmpt through the attribute induction_queue. The prove_helper method of BMC must manage the result of KInduction if there is one.\n❓ Implement the def prove_helper(self) -\u0026gt; int of the KInduction class, that iteratively constructs the $\\psi_i$ formulas and returns $i$ if $\\psi_i \\land F$ is UNSAT.\n2.3.4 - State Equation Over-Approximation We know propose a method specific to Petri nets. This method relies on the potentially reachable markings, that are the solutions of $m$ for the system $I \\cdot \\vec{z} + m_0 = m$, where $\\vec{z}$ is a vector of non-negative variables and $I$ is the incidence matrix. The incidence matrix $I$ of a net $N$ is the integer matrix of dimension $|P| \\times |T|$ (place-transition) with components $I(p, t) = \\mathrm{Post}(t, p) − \\mathrm{Pre}(t, p)$, for each place $p$ and each transition $t$. This method (as the previous ones) is still non-complete, but it can help us prove, in some cases, that a formula $F$ is not reachable.\nThis part is left as an open problem, and do not rely on the previous encoding.\n❓ Your goal is to implement the prove_helper(self) -\u0026gt; Optional[bool] method of the StateEquation class, that returns False is the formula has been proved as non-reachable, None otherwise.\nAppendix: Using the z3 interface with the SMT-LIB Format SMT-LIB (Satisfiability Modulo Theories LIBrary) is an interface language intended for use by programs designed to solve SMT (Satisfiability Modulo Theories) problems. You can find a complete documentation on the official website.\nGiven a z3 object (attribute solver in any AbstractChecker object) you can use several helper methods:\nwrite(str) -\u0026gt; None: write some instructions to the solver, reset() -\u0026gt; None: erase all assertions and declarations, push() -\u0026gt; None: creates a new scope by saving the current stack size, pop() -\u0026gt; None: removes any assertion and declaration performed between it and the last push, check_sat() -\u0026gt; Optional[bool]: returns if the current stack is satisfiable or not (a result of None means that there is an error with the stack). You can use option --debug of usmpt to display the exchanges between the program and the solver on the standard output.\nYou can try with some SMT-LIB queries on some online platforms such as Z3 Playground or Z3 Online Demonstrator.\nAn example of Boolean declarations and SAT assertions:\n; Variable declarations (declare-fun a () Bool) (declare-fun b () Bool) (declare-fun c () Bool) ; Constraints (assert (or a b)) (assert (not (and a c))) ; Solve (check-sat) An example of Integer declarations and QF-LIA assertions:\n; Variable declarations (declare-fun a () Int) (declare-fun b () Int) (declare-fun c () Int) ; Constraints (assert (\u0026gt; a 0)) (assert (\u0026gt; b 0)) (assert (\u0026gt; c 0)) (assert (= (+ a b) (* 2 c))) (assert (distinct a c)) ; Solve (check-sat) Note that the != operator in SMT-LIB is distinct.\n[^1] In the subject, we will use the two notations $A \\rightarrow B$ and $B^A$ interchangeably, for the type of mappings from $A$ to $B$.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"dbeb25c44f0ee9f4550e520b560819e2","permalink":"https://nicolasAmat.github.io/project/usmpt/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/project/usmpt/","section":"project","summary":"An educational project, targeting Master and PhD students to showcase the application of SMT methods in system verification, by developing a Petri net model checker for the reachability problem.","tags":["Teaching"],"title":"uSMPT","type":"project"}]